// Generated by CoffeeScript 1.6.3
(function() {
  $(function() {
    var Classifier, Point, ans, ans_w, boundary, canvas, canvas_static, center, counter, ctx, ctx_static, cycle, draw, finish, fps, height, init, m, points, points_num, radius, scale, update, width;
    m = Math;
    canvas = document.getElementById('canvas');
    ctx = canvas.getContext('2d');
    canvas_static = document.getElementById('canvas_static');
    ctx_static = canvas_static.getContext('2d');
    width = $('#canvas').width();
    height = $('#canvas').height();
    scale = width;
    radius = width / 2;
    center = {
      x: width / 2,
      y: height / 2
    };
    fps = 30;
    CanvasRenderingContext2D.prototype.drawPoint = function(x, y, sign, radius) {
      if (sign == null) {
        sign = 1;
      }
      if (radius == null) {
        radius = 2;
      }
      x *= scale;
      y *= scale;
      this.beginPath();
      if (sign >= 0) {
        this.fillStyle = 'rgb(255, 0, 0)';
      } else {
        this.fillStyle = 'rgb(0, 0, 255)';
      }
      this.arc(x, y, radius, 0, Math.PI * 2, false);
      return this.fill();
    };
    CanvasRenderingContext2D.prototype.drawLine = function(a, b) {
      this.beginPath();
      this.moveTo(a.x * scale, a.y * scale);
      this.lineTo(b.x * scale, b.y * scale);
      return this.stroke();
    };
    Point = (function() {
      function Point(x, y) {
        this.x = x != null ? x : 0;
        this.y = y != null ? y : 0;
      }

      Point.prototype.draw = function(static_draw) {
        if (static_draw == null) {
          static_draw = false;
        }
        if (static_draw) {
          return ctx_static.drawPoint(this.x, this.y, this.sign);
        } else {
          return ctx.drawPoint(this.x, this.y, this.sign);
        }
      };

      Point.prototype.set_val = function(val) {
        this.val = val;
        return this.sign = this.val >= 0 ? 1 : -1;
      };

      return Point;

    })();
    Classifier = (function() {
      function Classifier(w) {
        this.w = w != null ? w : [0, 0, 0];
      }

      Classifier.prototype.calc = function(p) {
        var val;
        return val = p.x * this.w[0] + p.y * this.w[1] + this.w[2];
      };

      Classifier.prototype.draw = function(static_draw) {
        var a, b, c, p0, p1;
        if (static_draw == null) {
          static_draw = false;
        }
        a = this.w[0];
        b = this.w[1];
        c = this.w[2];
        if (b === 0) {
          if (a === 0) {
            return;
          }
          p0 = {
            x: 0,
            y: -c / a
          };
          p1 = {
            x: width,
            y: -c / a
          };
        } else {
          p0 = {
            x: 0,
            y: -c / b
          };
          p1 = {
            x: width,
            y: -width * a / b + -c / b
          };
        }
        if (static_draw) {
          return ctx_static.drawLine(p0, p1);
        } else {
          return ctx.drawLine(p0, p1);
        }
      };

      return Classifier;

    })();
    ans = null;
    boundary = null;
    points = null;
    ans_w = [-1, 1, 0.1];
    counter = 0;
    finish = false;
    points_num = 100;
    init = function() {
      var i, p, _i, _j, _len, _len1, _results;
      ans = new Classifier(ans_w);
      boundary = new Classifier();
      points = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= points_num ? _i < points_num : _i > points_num; i = 0 <= points_num ? ++_i : --_i) {
          _results.push(new Point(m.random(), m.random()));
        }
        return _results;
      })();
      for (_i = 0, _len = points.length; _i < _len; _i++) {
        p = points[_i];
        p.set_val(ans.calc(p));
      }
      counter = 0;
      finish = false;
      _results = [];
      for (_j = 0, _len1 = points.length; _j < _len1; _j++) {
        p = points[_j];
        _results.push(p.draw(true));
      }
      return _results;
    };
    update = function() {
      var index, misses, next_points, p, sign, val;
      if (counter === 0) {
        next_points = [];
        while (points.length > 0) {
          index = m.floor(m.random() * points.length);
          next_points.push(points[index]);
          points.splice(index, 1);
        }
        points = next_points;
        misses = 0;
      }
      p = points[counter];
      val = boundary.calc(p);
      sign = val >= 0 ? 1 : -1;
      if (sign !== p.sign) {
        boundary.w[0] += p.sign * p.x;
        boundary.w[1] += p.sign * p.y;
        boundary.w[2] += p.sign * 1;
        misses++;
      }
      counter++;
      if (counter === points_num) {
        if (misses === 0) {
          finish = true;
        }
        return counter = 0;
      }
    };
    draw = function() {
      ctx.clearRect(0, 0, width, height);
      boundary.draw();
      return $('#w_param').text("w = (" + boundary.w[0] + ", " + boundary.w[1] + ", " + boundary.w[2] + ")");
    };
    cycle = function() {
      update();
      if (finish) {
        return;
      }
      draw();
      return setTimeout(cycle, 1 / fps);
    };
    init();
    return cycle();
  });

}).call(this);
