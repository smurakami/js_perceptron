// Generated by CoffeeScript 1.6.3
(function() {
  $(function() {
    var Classifier, Point, ans, ans_w, boundary, canvas, canvas_static, convert_x, convert_y, counter, ctx, ctx_static, cycle, draw, finish, fps, height, init, m, max_x, max_y, min_x, min_y, points, points_num, scale_x, scale_y, update, width;
    m = Math;
    canvas = document.getElementById('canvas');
    ctx = canvas.getContext('2d');
    canvas_static = document.getElementById('canvas_static');
    ctx_static = canvas_static.getContext('2d');
    width = $('#canvas').width();
    height = $('#canvas').height();
    min_x = -1;
    max_x = 1;
    min_y = -1;
    max_y = 1;
    scale_x = width / (max_x - min_x);
    scale_y = height / (max_y - min_y);
    fps = 30;
    convert_x = function(x) {
      return (x - min_x) * scale_x;
    };
    convert_y = function(y) {
      return height - (y - min_y) * scale_y;
    };
    CanvasRenderingContext2D.prototype.drawPoint = function(x, y, sign, radius) {
      if (sign == null) {
        sign = 1;
      }
      if (radius == null) {
        radius = 2;
      }
      x = convert_x(x);
      y = convert_y(y);
      this.beginPath();
      if (sign >= 0) {
        this.fillStyle = 'rgb(255, 0, 0)';
      } else {
        this.fillStyle = 'rgb(0, 0, 255)';
      }
      this.arc(x, y, radius, 0, Math.PI * 2, false);
      return this.fill();
    };
    CanvasRenderingContext2D.prototype.drawLine = function(a, b) {
      this.beginPath();
      this.moveTo(convert_x(a.x), convert_y(a.y));
      this.lineTo(convert_x(b.x), convert_y(b.y));
      return this.stroke();
    };
    Point = (function() {
      function Point(x, y) {
        this.x = x != null ? x : 0;
        this.y = y != null ? y : 0;
      }

      Point.prototype.draw = function(static_draw) {
        if (static_draw == null) {
          static_draw = false;
        }
        if (static_draw) {
          return ctx_static.drawPoint(this.x, this.y, this.sign);
        } else {
          return ctx.drawPoint(this.x, this.y, this.sign);
        }
      };

      Point.prototype.set_val = function(val) {
        this.val = val;
        return this.sign = this.val >= 0 ? 1 : -1;
      };

      return Point;

    })();
    Classifier = (function() {
      function Classifier(w) {
        this.w = w != null ? w : [0, 0, 0];
      }

      Classifier.prototype.calc = function(p) {
        var val;
        return val = p.x * this.w[0] + p.y * this.w[1] + this.w[2];
      };

      Classifier.prototype.draw = function(static_draw) {
        var a, b, c, p0, p1;
        if (static_draw == null) {
          static_draw = false;
        }
        a = this.w[0];
        b = this.w[1];
        c = this.w[2];
        if (b === 0) {
          if (a === 0) {
            return;
          }
          p0 = {
            x: -c / a,
            y: min_y
          };
          p1 = {
            x: -c / a,
            y: max_y
          };
        } else {
          p0 = {
            x: min_x,
            y: -(min_x * a + c) / b
          };
          p1 = {
            x: max_x,
            y: -(max_x * a + c) / b
          };
        }
        if (static_draw) {
          return ctx_static.drawLine(p0, p1);
        } else {
          return ctx.drawLine(p0, p1);
        }
      };

      return Classifier;

    })();
    ans = null;
    boundary = null;
    points = null;
    ans_w = [-1, 1, 0.1];
    counter = 0;
    finish = false;
    points_num = 100;
    init = function() {
      var i, p, x0, x1, y0, y1, _i, _j, _len, _len1;
      ans = new Classifier(ans_w);
      boundary = new Classifier();
      points = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= points_num ? _i < points_num : _i > points_num; i = 0 <= points_num ? ++_i : --_i) {
          _results.push(new Point(min_x + (max_x - min_x) * m.random(), min_y + (max_y - min_y) * m.random()));
        }
        return _results;
      })();
      for (_i = 0, _len = points.length; _i < _len; _i++) {
        p = points[_i];
        p.set_val(ans.calc(p));
      }
      counter = 0;
      finish = false;
      for (_j = 0, _len1 = points.length; _j < _len1; _j++) {
        p = points[_j];
        p.draw(true);
      }
      x0 = {
        x: min_x,
        y: 0
      };
      x1 = {
        x: max_x,
        y: 0
      };
      ctx_static.drawLine(x0, x1);
      y0 = {
        x: 0,
        y: min_y
      };
      y1 = {
        x: 0,
        y: max_y
      };
      return ctx_static.drawLine(y0, y1);
    };
    update = function() {
      var index, misses, next_points, p, sign, val;
      if (counter === 0) {
        next_points = [];
        while (points.length > 0) {
          index = m.floor(m.random() * points.length);
          next_points.push(points[index]);
          points.splice(index, 1);
        }
        points = next_points;
        misses = 0;
      }
      p = points[counter];
      val = boundary.calc(p);
      sign = val >= 0 ? 1 : -1;
      if (sign !== p.sign) {
        boundary.w[0] += p.sign * p.x;
        boundary.w[1] += p.sign * p.y;
        boundary.w[2] += p.sign * 1;
        misses++;
      }
      counter++;
      if (counter === points_num) {
        if (misses === 0) {
          finish = true;
        }
        return counter = 0;
      }
    };
    draw = function() {
      ctx.clearRect(0, 0, width, height);
      boundary.draw();
      return $('#w_param').text("w = (" + boundary.w[0] + ", " + boundary.w[1] + ", " + boundary.w[2] + ")");
    };
    cycle = function() {
      update();
      if (finish) {
        return;
      }
      draw();
      return setTimeout(cycle, 1 / fps);
    };
    init();
    return cycle();
  });

}).call(this);
