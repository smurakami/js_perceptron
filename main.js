// Generated by CoffeeScript 1.6.3
(function() {
  $(function() {
    var Classifier, Point, ans, boundary, canvas, center, counter, ctx, cycle, draw, finish, fps, height, i, line, m, p, points, points_num, radius, update, width, _i, _len;
    m = Math;
    canvas = document.getElementById('canvas');
    ctx = canvas.getContext('2d');
    width = $('#canvas').width();
    height = $('#canvas').height();
    radius = width / 2;
    center = {
      x: width / 2,
      y: height / 2
    };
    fps = 30;
    ctx.drawPoint = function(x, y, val, radius) {
      if (val == null) {
        val = 1;
      }
      if (radius == null) {
        radius = 2;
      }
      this.beginPath();
      if (val >= 0) {
        this.fillStyle = 'rgb(255, 0, 0)';
      } else {
        this.fillStyle = 'rgb(0, 0, 255)';
      }
      this.arc(x, y, radius, 0, Math.PI * 2, false);
      return this.fill();
    };
    ctx.drawLine = function(a, b) {
      this.beginPath();
      this.moveTo(a.x, a.y);
      this.lineTo(b.x, b.y);
      return this.stroke();
    };
    Point = (function() {
      function Point(x, y) {
        this.x = x != null ? x : 0;
        this.y = y != null ? y : 0;
      }

      Point.prototype.draw = function() {
        return ctx.drawPoint(this.x, this.y, this.val);
      };

      return Point;

    })();
    Classifier = (function() {
      function Classifier(w) {
        this.w = w != null ? w : [0, 0, 0];
      }

      Classifier.prototype.calc = function(p) {
        var val;
        val = p.x * this.w[0] + p.y * this.w[1] + this.w[2];
        if (val >= 0) {
          return 1;
        } else {
          return -1;
        }
      };

      Classifier.prototype.draw = function() {
        var a, b, c, p0, p1;
        a = this.w[0];
        b = this.w[1];
        c = this.w[2];
        if (b === 0) {
          if (a === 0) {
            return;
          }
          p0 = {
            x: 0,
            y: -c / a
          };
          p1 = {
            x: width,
            y: -c / a
          };
        } else {
          p0 = {
            x: 0,
            y: -c / b
          };
          p1 = {
            x: width,
            y: -width * a / b + -c / b
          };
        }
        return ctx.drawLine(p0, p1);
      };

      return Classifier;

    })();
    boundary = [-1, 1, 0];
    ans = new Classifier(boundary);
    line = new Classifier();
    points_num = 100;
    points = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= points_num ? _i < points_num : _i > points_num; i = 0 <= points_num ? ++_i : --_i) {
        _results.push(new Point(width * m.random(), height * m.random()));
      }
      return _results;
    })();
    for (_i = 0, _len = points.length; _i < _len; _i++) {
      p = points[_i];
      p.val = ans.calc(p);
    }
    counter = 0;
    finish = false;
    update = function() {
      var index, misses, next_p;
      if (counter === 0) {
        next_p = [];
        while (p.length > 0) {
          index = m.floor(m.random() * p.length);
          next_p.push(p[index]);
          p.slice(index, 1);
        }
        p = next_p;
        misses = 0;
      }
      counter++;
      if (counter === points_num) {
        if (misses === 0) {
          finish = true;
        }
        return counter = 0;
      }
    };
    draw = function() {
      var _j, _len1;
      ctx.clearRect(0, 0, width, height);
      for (_j = 0, _len1 = points.length; _j < _len1; _j++) {
        p = points[_j];
        p.draw();
      }
      return line.draw();
    };
    cycle = function() {
      update();
      if (finish) {
        return;
      }
      draw();
      return setTimeout(cycle, 1 / fps);
    };
    return cycle();
  });

}).call(this);
