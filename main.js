// Generated by CoffeeScript 1.6.3
(function() {
  $(function() {
    var Classifier, Point, ans, boundary, canvas, center, counter, ctx, cycle, draw, finish, fps, height, i, m, p, param, points, points_num, radius, update, width, _i, _len;
    m = Math;
    canvas = document.getElementById('canvas');
    ctx = canvas.getContext('2d');
    width = $('#canvas').width();
    height = $('#canvas').height();
    radius = width / 2;
    center = {
      x: width / 2,
      y: height / 2
    };
    fps = 30;
    ctx.drawPoint = function(x, y, sign, radius) {
      if (sign == null) {
        sign = 1;
      }
      if (radius == null) {
        radius = 2;
      }
      this.beginPath();
      if (sign >= 0) {
        this.fillStyle = 'rgb(255, 0, 0)';
      } else {
        this.fillStyle = 'rgb(0, 0, 255)';
      }
      this.arc(x, y, radius, 0, Math.PI * 2, false);
      return this.fill();
    };
    ctx.drawLine = function(a, b) {
      this.beginPath();
      this.moveTo(a.x, a.y);
      this.lineTo(b.x, b.y);
      return this.stroke();
    };
    Point = (function() {
      function Point(x, y) {
        this.x = x != null ? x : 0;
        this.y = y != null ? y : 0;
      }

      Point.prototype.draw = function() {
        return ctx.drawPoint(this.x, this.y, this.sign);
      };

      Point.prototype.set_val = function(val) {
        this.val = val;
        return this.sign = this.val >= 0 ? 1 : -1;
      };

      return Point;

    })();
    Classifier = (function() {
      function Classifier(w) {
        this.w = w != null ? w : [0, 0, 0];
      }

      Classifier.prototype.calc = function(p) {
        var val;
        return val = p.x * this.w[0] + p.y * this.w[1] + this.w[2];
      };

      Classifier.prototype.draw = function() {
        var a, b, c, p0, p1;
        a = this.w[0];
        b = this.w[1];
        c = this.w[2];
        if (b === 0) {
          if (a === 0) {
            return;
          }
          p0 = {
            x: 0,
            y: -c / a
          };
          p1 = {
            x: width,
            y: -c / a
          };
        } else {
          p0 = {
            x: 0,
            y: -c / b
          };
          p1 = {
            x: width,
            y: -width * a / b + -c / b
          };
        }
        return ctx.drawLine(p0, p1);
      };

      return Classifier;

    })();
    boundary = [0, 1, -width / 2];
    ans = new Classifier(boundary);
    p = new Point(1, 0);
    p.set_val(ans.calc(p));
    console.log(p.val);
    console.log(p.sign);
    param = new Classifier();
    points_num = 100;
    points = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= points_num ? _i < points_num : _i > points_num; i = 0 <= points_num ? ++_i : --_i) {
        _results.push(new Point(width * m.random(), height * m.random()));
      }
      return _results;
    })();
    for (_i = 0, _len = points.length; _i < _len; _i++) {
      p = points[_i];
      p.set_val(ans.calc(p));
    }
    counter = 0;
    finish = false;
    update = function() {
      var index, misses, next_points, sign, val;
      if (counter === 0) {
        next_points = [];
        while (points.length > 0) {
          index = m.floor(m.random() * points.length);
          next_points.push(points[index]);
          points.splice(index, 1);
        }
        points = next_points;
        misses = 0;
      }
      p = points[counter];
      val = param.calc(p);
      sign = val >= 0 ? 1 : -1;
      if (sign !== p.sign) {
        param.w[0] += p.sign * p.x;
        param.w[1] += p.sign * p.y;
        param.w[2] += p.sign * 1;
        misses++;
      }
      counter++;
      if (counter === points_num) {
        if (misses === 0) {
          finish = true;
        }
        return counter = 0;
      }
    };
    draw = function() {
      var _j, _len1;
      ctx.clearRect(0, 0, width, height);
      for (_j = 0, _len1 = points.length; _j < _len1; _j++) {
        p = points[_j];
        p.draw();
      }
      param.draw();
      return $('#w_param').text("w = (" + param.w[0] + ", " + param.w[1] + ", " + param.w[2] + ")");
    };
    cycle = function() {
      update();
      if (finish) {
        return;
      }
      draw();
      return setTimeout(cycle, 1 / fps);
    };
    return cycle();
  });

}).call(this);
